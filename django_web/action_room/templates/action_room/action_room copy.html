{% load static %}
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Wake-Word Detector</title>
    <!-- 1. Tải Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Tải ONNX Runtime (để chạy model) -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
    
    <!-- 3. Tải TensorFlow.js (chỉ để tiền xử lý STFT) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
    
    <style>
        /* Thêm style cho nút bấm disabled */
        #toggle-btn:disabled {
            background-color: #9ca3af; /* gray-400 */
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans antialiased">
    <div class="container mx-auto p-4 sm:p-8 max-w-2xl">
        <div class="bg-white rounded-lg shadow-xl overflow-hidden">
            <div class="p-6 sm:p-8">
                <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-800 mb-6">
                    Real-time Wake Word Detector
                </h1>
                
                <p class="text-center text-gray-600 mb-6">
                    Nhấn "Bắt đầu" và thử nói từ khóa.
                    Model đang nghe và phân tích liên tục trong trình duyệt.
                </p>

                <!-- Vùng điều khiển -->
                <div class="flex justify-center mb-6">
                    <button id="toggle-btn"
                            class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg text-lg transition duration-300"
                            onclick="toggleListening()">
                        Bắt đầu nghe
                    </button>
                </div>

                <!-- Vùng hiển thị trạng thái/kết quả -->
                <div id="status" class="mt-6 text-center p-4 rounded-lg bg-gray-50 hidden"></div>

            </div>
        </div>
    </div>

    <script>
        // --- CÀI ĐẶT CẤU HÌNH (TỪ FILE CŨ CỦA BẠN) ---
        
        // 1. Đường dẫn model (đã sửa)
        const ONNX_MODEL_PATH = "{% static 'model/voice_model_from_spec.onnx' %}";
        
        // 2. Các tham số xử lý (đã sửa)
        const TARGET_SR = 16000;
        const TARGET_LENGTH = 40000; // 2.5 giây * 16000
        const N_FFT = 400;           // Phải khớp với model (201 bins)
        const HOP_LENGTH = 512;
        
        // 3. Ngưỡng (Threshold)
        const THRESHOLD = 0.5; // Bạn có thể chỉnh giá trị này (vd: 0.8)

        // 4. Khoảng thời gian giữa 2 lần dự đoán (tính bằng mili-giây)
        // Số càng nhỏ, model chạy càng nhiều, càng tốn CPU
        const INFERENCE_INTERVAL_MS = 750; // Chạy dự đoán mỗi 0.75 giây

        // --- Biến toàn cục (Global Variables) ---
        let ortSession;
        let isListening = false;
        let audioContext;
        let micStream;
        let scriptProcessor;
        let audioBuffer = new Float32Array(0); // Bộ đệm âm thanh thô (ở SR gốc)
        let inferenceInterval;

        const statusDiv = document.getElementById('status');
        const toggleBtn = document.getElementById('toggle-btn');

        // =================================================================
        // CÁC HÀM CỐT LÕI (GIỮ NGUYÊN TỪ FILE CŨ CỦA BẠN)
        // =================================================================

        // 2. Resample (GIỮ NGUYÊN)
        async function resampleAudio(audioBuffer, targetSampleRate) {
            if (audioBuffer.sampleRate === targetSampleRate) {
                return audioBuffer.getChannelData(0);
            }
            const duration = audioBuffer.duration;
            const offlineContext = new OfflineAudioContext(
                1, Math.ceil(duration * targetSampleRate), targetSampleRate
            );
            const bufferSource = offlineContext.createBufferSource();
            bufferSource.buffer = audioBuffer;
            bufferSource.connect(offlineContext.destination);
            bufferSource.start();
            const resampledBuffer = await offlineContext.startRendering();
            return resampledBuffer.getChannelData(0);
        }

        // 3. Pad/Cut (GIỮ NGUYÊN)
        function padOrCut(data, length) {
            if (data.length > length) {
                return data.slice(0, length);
            } else if (data.length < length) {
                const paddedData = new Float32Array(length).fill(0);
                paddedData.set(data);
                return paddedData;
            }
            return data;
        }

        // 4. Tính Spectrogram (GIỮ NGUYÊN VÀ ĐÃ SỬA CHO N_FFT=400)
        async function computeSpectrogram(data) {
            const padWidth = N_FFT / 2; // 400 / 2 = 200
            const inputTensor = tf.tensor1d(data);
            // 1. Reflect padding [[200, 200]]
            const paddedTensor = tf.mirrorPad(inputTensor, [[padWidth, padWidth]], 'reflect');
            // 2. STFT -> [79, 201]
            const stft = tf.signal.stft(
                paddedTensor, N_FFT, HOP_LENGTH, N_FFT, tf.signal.hannWindow
            );
            // 3. Power Spectrogram
            const powerSpec = tf.square(tf.abs(stft));
            // 4. Transpose -> [201, 79]
            const transposedSpec = powerSpec.transpose([1, 0]);

            // Dọn dẹp
            inputTensor.dispose();
            paddedTensor.dispose();
            stft.dispose();
            powerSpec.dispose();
            
            return transposedSpec; // Trả về tensor [201, 79]
        }

        // 5. Chạy Model (GIỮ NGUYÊN)
        async function runOnnxModel(spectrogramTensor) {
            const specData = await spectrogramTensor.data();
            const dims = spectrogramTensor.shape; // [201, 79]
            // Thêm chiều batch [1, 201, 79]
            const ortTensor = new ort.Tensor('float32', specData, [1, ...dims]);
            const inputs = { 'spectrogram': ortTensor };
            const results = await ortSession.run(inputs);
            const logit = results.logits.data[0];
            const probability = 1 / (1 + Math.exp(-logit));
            const prediction = probability > THRESHOLD ? "True" : "False";
            spectrogramTensor.dispose();
            return [prediction, probability];
        }

        // 6. Cập nhật UI (GIỮ NGUYÊN)
        function updateStatus(message, type) {
             statusDiv.classList.remove('hidden', 'bg-gray-50', 'bg-blue-100', 'bg-green-100', 'bg-red-100', 'text-gray-800', 'text-blue-800', 'text-green-800', 'text-red-800');
            let baseClass = 'p-4 rounded-lg';
            let typeClass = '';
            if (type === 'loading') {
                typeClass = 'bg-blue-100 text-blue-800';
                message = `<div class="flex items-center justify-center"><svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> <span>${message}</span></div>`;
            } else if (type === 'success') {
                typeClass = 'bg-green-100 text-green-800';
            } else if (type === 'error') {
                typeClass = 'bg-red-100 text-red-800';
            } else {
                typeClass = 'bg-gray-50 text-gray-800';
            }
            statusDiv.className = `${baseClass} ${typeClass}`;
            statusDiv.innerHTML = message;
        }

        // =================================================================
        // LOGIC MỚI (REAL-TIME)
        // =================================================================

        // 0. Tải model khi trang mở
        async function loadModel() {
            toggleBtn.disabled = true;
            try {
                updateStatus("Đang tải model ONNX...", "loading");
                ortSession = await ort.InferenceSession.create(ONNX_MODEL_PATH);
                updateStatus("Model đã sẵn sàng. Nhấn 'Bắt đầu nghe' để chạy.", "success");
                toggleBtn.disabled = false;
            } catch (e) {
                updateStatus(`Lỗi khi tải model: ${e.message}`, "error");
            }
        }
        
        // 1. Hàm chính điều khiển Bắt đầu / Dừng
        function toggleListening() {
            if (isListening) {
                stopListening();
            } else {
                startListening();
            }
        }

        // 2. Bắt đầu nghe
        async function startListening() {
            if (!ortSession) {
                updateStatus("Lỗi: Model chưa được tải.", "error");
                return;
            }

            try {
                updateStatus("Yêu cầu quyền truy cập micro...", "loading");
                // 1. Tạo AudioContext và lấy stream
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // 2. Tạo ScriptProcessor để nhận data
                // bufferSize 4096, 1 kênh vào, 1 kênh ra
                scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                // 3. Đăng ký callback
                // Hàm này sẽ chạy mỗi khi buffer 4096-sample đầy
                scriptProcessor.onaudioprocess = processAudioChunk;
                
                // 4. Kết nối các node
                const source = audioContext.createMediaStreamSource(micStream);
                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination); // Phải kết nối để nó chạy

                // 5. Bắt đầu vòng lặp dự đoán
                // Cứ mỗi 750ms, chúng ta sẽ chạy hàm runInference
                inferenceInterval = setInterval(runInference, INFERENCE_INTERVAL_MS);

                isListening = true;
                toggleBtn.textContent = "Dừng nghe";
                toggleBtn.classList.replace('bg-blue-500', 'bg-red-500');
                toggleBtn.classList.replace('hover:bg-blue-600', 'hover:bg-red-600');
                updateStatus("Đang nghe...", "loading");

            } catch (e) {
                updateStatus(`Lỗi micro: ${e.message}. Vui lòng cấp quyền truy cập.`, "error");
            }
        }

        // 3. Dừng nghe
        function stopListening() {
            if (!isListening) return;

            try {
                // Dừng vòng lặp
                clearInterval(inferenceInterval);
                inferenceInterval = null;

                // Dừng các node audio
                scriptProcessor.disconnect();
                micStream.getTracks().forEach(track => track.stop());
                audioContext.close();

                // Reset trạng thái
                isListening = false;
                audioBuffer = new Float32Array(0); // Xóa buffer
                toggleBtn.textContent = "Bắt đầu nghe";
                toggleBtn.classList.replace('bg-red-500', 'bg-blue-500');
                toggleBtn.classList.replace('hover:bg-red-600', 'hover:bg-blue-600');
                updateStatus("Đã dừng. Nhấn 'Bắt đầu' để nghe lại.", "success");
            } catch (e) {
                console.error("Lỗi khi dừng:", e);
                updateStatus("Đã dừng.", "success");
            }
        }

        // 4. Callback xử lý từng khối âm thanh (Sync)
        // Hàm này chỉ làm 1 việc: đưa data vào buffer
        function processAudioChunk(event) {
            if (!isListening) return;
            
            // Lấy data âm thanh (ở SR gốc của trình duyệt, vd: 48000Hz)
            const newChunk = event.inputBuffer.getChannelData(0);
            
            // Thêm vào buffer
            const newBuffer = new Float32Array(audioBuffer.length + newChunk.length);
            newBuffer.set(audioBuffer);
            newBuffer.set(newChunk, audioBuffer.length);
            audioBuffer = newBuffer;

            // Giới hạn buffer, chỉ giữ 5 giây cuối để tránh tràn bộ nhớ
            const maxBufferLength = (audioContext.sampleRate * 5); 
            if (audioBuffer.length > maxBufferLength) {
                audioBuffer = audioBuffer.slice(audioBuffer.length - maxBufferLength);
            }
        }

        // 5. Hàm chạy dự đoán (Async)
        // Hàm này được gọi bởi setInterval
        async function runInference() {
            if (!isListening) return;

            // Tính toán số mẫu ở SR gốc tương đương với 2.5s (40000 mẫu ở 16kHz)
            const requiredNativeSamples = Math.floor(TARGET_LENGTH * (audioContext.sampleRate / TARGET_SR));
            
            // Nếu buffer chưa đủ 2.5s, chờ
            if (audioBuffer.length < requiredNativeSamples) {
                updateStatus("Đang nghe (chờ đủ buffer)...", "loading");
                return;
            }

            // Lấy 2.5s âm thanh cuối cùng từ buffer
            const audioChunk = audioBuffer.slice(audioBuffer.length - requiredNativeSamples);

            // Tạm thời vô hiệu hóa nút bấm trong khi xử lý
            toggleBtn.disabled = true;
            updateStatus("Đang phân tích...", "loading");

            try {
                // --- Chạy pipeline (y hệt code cũ) ---
                
                // 1. Tạo AudioBuffer object để dùng hàm resample
                const bufferToResample = audioContext.createBuffer(1, audioChunk.length, audioContext.sampleRate);
                bufferToResample.copyToChannel(audioChunk, 0);

                // 2. Resample (Async)
                const resampledData = await resampleAudio(bufferToResample, TARGET_SR);
                
                // 3. Pad/Cut (Async - dù hàm là sync)
                const processedData = padOrCut(resampledData, TARGET_LENGTH);
                
                // 4. Tính Spectrogram (Async)
                const spectrogramTensor = await computeSpectrogram(processedData);
                
                // 5. Chạy Model (Async)
                const [prediction, probability] = await runOnnxModel(spectrogramTensor);

                // 6. Kiểm tra kết quả
                if (prediction === "True" && probability > THRESHOLD) {
                    // PHÁT HIỆN TỪ KHÓA!
                    updateStatus(
                        `<strong>Phát hiện từ khóa!</strong><br>
                         Xác suất: ${(probability * 100).toFixed(2)}%`,
                        "success"
                    );
                    stopListening(); // Dừng lại khi đã phát hiện
                } else {
                    // Vẫn đang nghe
                    updateStatus(
                        `Đang nghe... (Gần nhất: ${(probability * 100).toFixed(2)}%)`,
                        "loading"
                    );
                    toggleBtn.disabled = false; // Bật lại nút
                }
            } catch (e) {
                updateStatus(`Lỗi khi dự đoán: ${e.message}`, "error");
                toggleBtn.disabled = false; // Bật lại nút
            }
        }

        // Tải model ngay khi trang được mở
        loadModel();

    </script>
</body>
</html>
